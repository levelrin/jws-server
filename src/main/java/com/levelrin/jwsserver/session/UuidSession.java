/*
 * Copyright (c) 2020 Rin (https://www.levelrin.com)
 *
 * This file has been created under the terms of the MIT License.
 * See the details at https://github.com/levelrin/jws-server/blob/main/LICENSE
 */

package com.levelrin.jwsserver.session;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * The id of this session is generated by {@link java.util.UUID}.
 * It's not thread-safe.
 */
public final class UuidSession implements Session {

    /**
     * We will use this to send a message to the client.
     */
    private final Socket socket;

    /**
     * We will store the ID into this.
     */
    private final List<String> idCache = new ArrayList<>(1);

    /**
     * Constructor.
     * @param socket See {@link UuidSession#socket}.
     */
    public UuidSession(final Socket socket) {
        this.socket = socket;
    }

    @Override
    @SuppressWarnings("PMD.ShortMethodName")
    public String id() {
        if (this.idCache.isEmpty()) {
            this.idCache.add(
                UUID.randomUUID().toString()
            );
        }
        return this.idCache.get(0);
    }

    /**
     * It will not add a line break at the end.
     * We assume the message is in UTF-8.
     * It always send the message in a complete frame without fragmentation.
     * @param message Content of the message.
     */
    @Override
    @SuppressWarnings("MagicNumber")
    public void sendMessage(final String message) {
        this.sendMessage(
            message.getBytes(StandardCharsets.UTF_8),
            // -127 is equivalent to 10000001,
            // which means it's a FIN frame with TEXT data.
            -127
        );
    }

    /**
     * It always send the message in a complete frame without fragmentation.
     * @param message Content of the message.
     */
    @Override
    @SuppressWarnings("MagicNumber")
    public void sendMessage(final byte[] message) {
        this.sendMessage(
            message,
            // -126 is equivalent to 10000010,
            // which means it's a FIN frame with binary data.
            -126
        );
    }

    /**
     * This method is created to remove the duplicated code.
     * The way we send a text and binary messages are almost identical.
     * The only difference is the opcode.
     * For that reason, we extract the initial byte, which contains the opcode.
     * The rest of procedure is the same for both text and binary messages.
     * @param message The payload data.
     * @param initialByte Initial byte of the frame in decimal.
     */
    @SuppressWarnings({"MagicNumber", "PMD.CloseResource"})
    private void sendMessage(final byte[] message, final int initialByte) {
        try {
            final ByteArrayOutputStream stream = new ByteArrayOutputStream();
            stream.write(initialByte);
            final int length = message.length;
            // If the content length is less than 126,
            // we don't have to worry about the extended payload length.
            if (length < 126) {
                stream.write(length);
                // If the content length is greater than 126,
                // we need to specify the extended payload length.
                // The maximum number that 16 bits can represent is 65,535.
                // So, this condition would be the extended payload length
                // with the following 2 bytes.
            } else if (length <= 65_535) {
                // 126 means the following 2 bytes would be the payload length.
                stream.write(126);
                // It's important to allocate 2 bytes
                // because the next 2 bytes would be the payload length.
                // Also, we must put short data because the short data type is 2 bytes.
                stream.write(ByteBuffer.allocate(2).putShort((short) length).array());
            } else {
                // 127 means the following 8 bytes would be the payload length.
                stream.write(127);
                // It's important to allocate 8 bytes
                // because the next 8 bytes would be the payload length.
                // Also, we must put long data because the long data type is 8 bytes.
                stream.write(ByteBuffer.allocate(8).putLong(length).array());
            }
            stream.write(message);
            final OutputStream output = this.socket.getOutputStream();
            output.write(stream.toByteArray());
            output.flush();
        } catch (final IOException ioException) {
            throw new IllegalStateException(
                "Failed to send a message to the client.",
                ioException
            );
        }
    }

    @Override
    public void close() {
        throw new UnsupportedOperationException("Not implemented yet.");
    }

}
